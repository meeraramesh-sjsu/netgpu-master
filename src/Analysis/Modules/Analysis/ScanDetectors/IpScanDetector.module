/* 
	MODULE:IpScan detector
	TYPE: Analysis

	PrePreprocessor orders (ppp.sh): 

	###PATTERNS $IPSCAN_DETECTOR$ANALYSIS( 

*/

//#warning IpScan Analysis

#ifndef libAnalysisIpScan_h 
#define libAnalysisIpScan_h 

#include "../Thresholds/Thresholds.h"
#include <inttypes.h>
#include <string>
#include <stdio.h>
using namespace std;

typedef struct{
	uint32_t ipSrc;
	uint32_t ipSrcNetwork;
	uint32_t ipDst;
	uint32_t counter;
	uint8_t protocol;
	uint8_t version;
	float rate;
	unsigned char * data;
	uint16_t sport;
	uint16_t dport;
	int indexTcp;
	int indexUdp;
	int indexIcmp;
	int maliciousVer;
	int maliciousIP;
	char ipSrcStr[16];
}COMPOUND_NAME(ANALYSIS_NAME,ipScanAnalysis_t);

/*__device__ int indexTcp = 0;
__device__ int indexUdp = 0;
__device__ int indexIcmp = 0;
__device__ int totalThreads=0;
*/
#endif  //libAnalysisIpScan

/* Redefine TYPES */
#undef  ANALYSIS_INPUT_TYPE
#define ANALYSIS_INPUT_TYPE COMPOUND_NAME(ANALYSIS_NAME,ipScanAnalysis_t)

#ifdef __CUDACC__

#define $IPSCAN_DETECTOR$AUTO_MINE()\
	do{\
	 if(IS_ETHERNET() && IS_IP4()){\
        DATA_ELEMENT.ipSrc = GET_FIELD(IP4_HEADER.ip_src);\
        DATA_ELEMENT.ipDst = GET_FIELD(IP4_HEADER.ip_dst);\
		DATA_ELEMENT.protocol = GET_FIELD(IP4_HEADER.protocol);\
		DATA_ELEMENT.version = IP4_HEADER.version;\
		DATA_ELEMENT.indexTcp=0;\
		DATA_ELEMENT.indexUdp=0;\
		DATA_ELEMENT.indexIcmp=0;\
		DATA_ELEMENT.maliciousVer=0;\	
		DATA_ELEMENT.maliciousIP=0;\	
		}\
		if(IS_TCP())\
		{\
		DATA_ELEMENT.sport = GET_FIELD(TCP_HEADER.sport);\
		DATA_ELEMENT.dport = GET_FIELD(TCP_HEADER.dport);\		
		}\
}while(0)
	
/***** IPSCAN DETECTOR ANALYSIS *****/
#define $IPSCAN_DETECTOR$ANALYSIS(threshold) \
	COMPOUND_NAME(ANALYSIS_NAME,ipScanAnalysisCode)(GPU_buffer,GPU_data,GPU_results,state,counter,threshold);\
	__syncthreads()

#define SHARED_BUFFER_SIZE MAX_BUFFER_PACKETS/ANALYSIS_TPB

template<typename T,typename R> 
__device__  void ipscananalysis(packet_t* GPU_buffer, T* GPU_data, R* GPU_results, analysisState_t state,int *counter,int thresHold){

/* Erases duplicates and counts elements inside block */
	__shared__ T elements[ANALYSIS_TPB];

		//Global Thread Index
		int threadIndex = blockIdx.x*blockDim.x + threadIdx.x;
		//Mine to Shared to save memory accesses
		elements[threadIdx.x] = cudaSafeGet(&GPU_data[threadIndex]);
		unsigned int octet1,octet2,octet3,octet4;
		//if(blockIdx.x==0) printf("Source Ip address of the thread with threadId %d in block %d is %" PRIu32 "\n", threadIdx.x,blockIdx.x,elements[threadIdx.x].ipSrc);
		
		//if(blockIdx.x==0) printf("version number of the thread with threadId %d in block %d is %d \n", threadIdx.x,blockIdx.x,elements[threadIdx.x].version);
		if(elements[threadIdx.x].protocol==6) //TCP packet
		{
		atomicAdd(&(GPU_results[0].indexTcp),1);
		}		
		if(elements[threadIdx.x].protocol==0x0011)  //UDP packet
		{
		atomicAdd(&(GPU_results[0].indexUdp),1);
		}
		if(elements[threadIdx.x].protocol==1) //ICMP packet
		{
		atomicAdd(&(GPU_results[0].indexIcmp),1);
		}
		/*Rules for Detecting Malicious IP Packets */
		/* In actual implementatiion REPLACE below line with 
		elements[threadIdx.x].version!=4 && elements[threadIdx.x].version!=6
		Since we have not injected malicous packets using below comparison*/
		if(elements[threadIdx.x].version==4) //Should be Malicious version
		{
		GPU_results[threadIndex].maliciousVer = 1;
		}
		
		//Checking if the source IP address is in Private Address range
		uint32_t sourceAddress = elements[threadIdx.x].ipSrc;
		 octet1 = (sourceAddress & 0xff000000) >> 24;
		 octet2 = (sourceAddress & 0x00ff0000) >> 16;
		 octet3 = (sourceAddress & 0x0000ff00) >> 8;
		 octet4 = (sourceAddress & 0x000000ff);
		  	  
		 snprintf (GPU_results[threadIndex].ipSrcStr, 16, "%d.%d.%d.%d",octet1,octet2,octet3,octet4);
 
		 if (octet1 == 10)
		 {
        GPU_results[threadIndex].maliciousIP=1;
        }
		
    // 172.16.0.0 - 172.31.255.255
  	  if ((octet1 == 172) && (octet2 >= 16) && (octet2 <= 31))
  	  {
       GPU_results[threadIndex].maliciousIP=1;
		}
    // 192.168.0.0 - 192.168.255.255
   	 if ((octet1 == 192) && (octet2 == 168))
   	 {
      GPU_results[threadIndex].maliciousIP=1;
	}	
	 //printf("Source IP address is %u.%u.%u.%u\n",octet1,octet2,octet3,octet4);
		 												
	__syncthreads();

  // atomicAdd(&totalThreads,1);
}

template<typename T,typename R> 
__device__ __inline__ void COMPOUND_NAME(ANALYSIS_NAME,ipScanAnalysisCode)(packet_t* GPU_buffer, T* GPU_data, R* GPU_results, analysisState_t state,int *counter,int thresHold){

	ipscananalysis<ANALYSIS_INPUT_TYPE,ANALYSIS_INPUT_TYPE>(GPU_buffer,GPU_data,GPU_results,state,counter,thresHold);
	//while(totalThreads<3840) { }; 
	}

/***** END OF PORTSCAN DETECTOR ANALYSIS *****/


#endif //__CUDACC__
/* Redefine DATA_ELEMENT and RESULT_ELEMENT */
#undef DATA_ELEMENT
#define DATA_ELEMENT GPU_data[POS] 

#undef RESULT_ELEMENT
#define RESULT_ELEMENT GPU_results[POS] 



