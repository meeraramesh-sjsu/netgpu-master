/* 
	MODULE:IpScan detector
	TYPE: Analysis

	PrePreprocessor orders (ppp.sh): 

	###PATTERNS $IPSCAN_DETECTOR$ANALYSIS( 

*/

//#warning IpScan Analysis

#ifndef libAnalysisIpScan_h 
#define libAnalysisIpScan_h 

#include "../Thresholds/Thresholds.h"
#include <inttypes.h>
#include <string>
#include <stdio.h>
using namespace std;
typedef struct{
	//IP
	uint8_t headerLength;
	uint8_t version;
	uint8_t	 tos;		
	uint16_t totalLength;
	uint16_t identification;			
	uint16_t flagsAndOffset;
	uint8_t  ttl;		
	uint8_t protocol;
	uint16_t checksum;
	uint32_t ipSrc;
	uint32_t ipDst;
	uint32_t ipSrcNetwork;
	uint32_t counter;
	uint8_t flags;
	uint8_t unused;
	float rate;
	unsigned char * data;
	uint16_t sport;
	uint16_t dport;
	uint32_t ack;
	u_short *addr;
	int indexTcp;
	int indexUdp;
	int indexIcmp;
	int maliciousVer;
	int maliciousIP;
	int maliciousFlags;
	int maliciousReserved;
	int maliciousPort;
	int maliciousAck;
	int maliciousDst;
	int ipLen;
}COMPOUND_NAME(ANALYSIS_NAME,ipScanAnalysis_t);

/*__device__ int indexTcp = 0;
__device__ int indexUdp = 0;
__device__ int indexIcmp = 0;
__device__ int totalThreads=0;
*/
#endif  //libAnalysisIpScan

/* Redefine TYPES */
#undef  ANALYSIS_INPUT_TYPE
#define ANALYSIS_INPUT_TYPE COMPOUND_NAME(ANALYSIS_NAME,ipScanAnalysis_t)

#ifdef __CUDACC__

#define $IPSCAN_DETECTOR$AUTO_MINE()\
	do{\
	 if(IS_ETHERNET() && IS_IP4()){\
		 DATA_ELEMENT.version=0;\
		 DATA_ELEMENT.ipSrc = GET_FIELD(IP4_HEADER.ip_src);\
		 DATA_ELEMENT.tos = IP4_HEADER.tos;\
		 DATA_ELEMENT.totalLength = GET_FIELD(IP4_HEADER.totalLength);\
		 DATA_ELEMENT.identification = GET_FIELD(IP4_HEADER.identification);\
		 DATA_ELEMENT.flagsAndOffset = GET_FIELD(IP4_HEADER.flagsAndOffset);\
		 DATA_ELEMENT.ttl = IP4_HEADER.ttl;\
		 DATA_ELEMENT.checksum = GET_FIELD(IP4_HEADER.checksum);\
		 DATA_ELEMENT.ipDst = GET_FIELD(IP4_HEADER.ip_dst);\
		 DATA_ELEMENT.protocol = IP4_HEADER.protocol;\
		 DATA_ELEMENT.version = IP4_HEADER.version;\
		 DATA_ELEMENT.headerLength = IP4_HEADER.headerLength;\
		 DATA_ELEMENT.indexTcp=0;\
		 DATA_ELEMENT.indexUdp=0;\
		 DATA_ELEMENT.indexIcmp=0;\
		 DATA_ELEMENT.maliciousVer=0;\	
		 DATA_ELEMENT.maliciousIP=0;\
		 DATA_ELEMENT.addr = IP4_HEADER_PTR;\
		 DATA_ELEMENT.ipLen = IP4_HEADER.headerLength * 4;\
		 		}\
		if(IS_TCP())\
		{\
		DATA_ELEMENT.flags = 0;\	
		DATA_ELEMENT.sport = GET_FIELD(TCP_HEADER.sport);\
		DATA_ELEMENT.dport = GET_FIELD(TCP_HEADER.dport);\	
		DATA_ELEMENT.ack = GET_FIELD(TCP_HEADER.ack);\
		DATA_ELEMENT.flags = TCP_HEADER.flags;\	
		DATA_ELEMENT.unused = TCP_HEADER.unused;\	
		DATA_ELEMENT.maliciousReserved = 0;\
		DATA_ELEMENT.maliciousFlags=0;\
		DATA_ELEMENT.maliciousPort=0;\
		}\
}while(0)
	
/***** IPSCAN DETECTOR ANALYSIS *****/
#define $IPSCAN_DETECTOR$ANALYSIS(threshold) \
	COMPOUND_NAME(ANALYSIS_NAME,ipScanAnalysisCode)(GPU_buffer,GPU_data,GPU_results,state,counter,threshold);\
	__syncthreads()

#define SHARED_BUFFER_SIZE MAX_BUFFER_PACKETS/ANALYSIS_TPB

template<typename T,typename R> 
__device__  void ipscananalysis(packet_t* GPU_buffer, T* GPU_data, R* GPU_results, analysisState_t state,int *counter,int thresHold){

/* Erases duplicates and counts elements inside block */
	__shared__ T elements[ANALYSIS_TPB];

		//Global Thread Index
		int threadIndex = blockIdx.x*blockDim.x + threadIdx.x;
		printf("*********Printing the IP Header*********");
		if(IS_IP4() && threadIndex==0)
		{
			int nleft = DATA_ELEMENT.headerLength*4;
			while (nleft > 1)  {
			      printf("%d ",*elements[threadIdx.x].addr++);
			        nleft -= 2;
			    }
		}
		printf("\n");
		//Mine to Shared to save memory accesses
		elements[threadIdx.x] = cudaSafeGet(&GPU_data[threadIndex]);
		unsigned int octet1,octet2,octet3,octet4,octet1Dst,octet2Dst,octet3Dst,octet4Dst;
		//if(blockIdx.x==0) printf("Source Ip address of the thread with threadId %d in block %d is %" PRIu32 "\n", threadIdx.x,blockIdx.x,elements[threadIdx.x].ipSrc);
		//if(blockIdx.x==0) printf("version number of the thread with threadId %d in block %d is %d \n", threadIdx.x,blockIdx.x,elements[threadIdx.x].version);
		/*Counting the number of TCP, UDP and ICMP Packets */
		if(elements[threadIdx.x].protocol==6) //TCP packet
		{
		atomicAdd(&(GPU_results[0].indexTcp),1);
		}		
		if(elements[threadIdx.x].protocol==0x0011)  //UDP packet
		{
		atomicAdd(&(GPU_results[0].indexUdp),1);
		}
		if(elements[threadIdx.x].protocol==1) //ICMP packet
		{
		atomicAdd(&(GPU_results[0].indexIcmp),1);
		}
		/*Rules for Detecting Malicious IP Packets */
		if(IS_IP4() || IS_IP6())
		{
			if(blockIdx.x==0)
			{
				//PRIu8 PRIu8 PRIu8 PRIu16 PRIu16 PRIu16 PRIu8 PRIu8 PRIu16 PRIu32 PRIu32
			printf("Printing the IP4 Header: % " PRIu8, /*," % " PRIu8," % " PRIu8," % " PRIu16 ," % " PRIu16," % " PRIu16," % "
					PRIu8," % " PRIu8," % " PRIu16," % " PRIu32," % " PRIu32,*/
			elements[threadIdx.x].headerLength);
			printf("Version: % " PRIu8,elements[threadIdx.x].version);
			printf("TOS: %" PRIu8,elements[threadIdx.x].tos);
		//	int verLenTOS =
			printf("Total Length: %" PRIu16, elements[threadIdx.x].totalLength);
			printf("Identification: %" PRIu16, elements[threadIdx.x].identification);
			printf("Flags and Offset: %" PRIu16, elements[threadIdx.x].flagsAndOffset);
			printf("TTL: %" PRIu8, elements[threadIdx.x].ttl);
			printf("Protocol: %" PRIu8, elements[threadIdx.x].protocol);
			printf("Checksum: %" PRIu16, elements[threadIdx.x].checksum);
			printf("Src Address: %" PRIu16, elements[threadIdx.x].ipSrc);
			printf("Dest Address: %" PRIu16, elements[threadIdx.x].ipDst);
			}
			/*,elements[threadIdx.x].version,\
			elements[threadIdx.x].tos,elements[threadIdx.x].totalLength,\
			elements[threadIdx.x].identification,elements[threadIdx.x].flagsAndOffset,\
			elements[threadIdx.x].ttl,elements[threadIdx.x].protocol,\
			elements[threadIdx.x].checksum,elements[threadIdx.x].ipSrc,\
			elements[threadIdx.x].ipDst);*/
			printf("\n");
		/*Checking if the version number in IP Packets is anything other than 4 or 6, 0 is because by default the value is 0*/
		if(elements[threadIdx.x].version!=4 && elements[threadIdx.x].version!=6 && elements[threadIdx.x].version!=0) //Should be Malicious version
		{
		GPU_results[threadIndex].maliciousVer = 1;
		}
		/*Checking if the source or destination IP address is in Private Address range*/
		GPU_results[threadIndex].ipSrc = GPU_data[threadIndex].ipSrc;
		GPU_results[threadIndex].ipDst = GPU_data[threadIndex].ipDst;
		//Checking if the source IP address is in Private Address range
		 uint32_t sourceAddress = elements[threadIdx.x].ipSrc;
		 octet1 = (sourceAddress & 0xff000000) >> 24;
		 octet2 = (sourceAddress & 0x00ff0000) >> 16;
		 octet3 = (sourceAddress & 0x0000ff00) >> 8;
		 octet4 = (sourceAddress & 0x000000ff);
		 uint32_t dstAddress = elements[threadIdx.x].ipDst;
		 octet1Dst = (dstAddress & 0xff000000) >> 24;
		 octet2Dst = (dstAddress & 0x00ff0000) >> 16;
		 octet3Dst = (dstAddress & 0x0000ff00) >> 8;
		 octet4Dst = (dstAddress & 0x000000ff);
		 if (octet1 == 10 || octet1Dst==10)
		 {
        GPU_results[threadIndex].maliciousIP=1;
        }
		
    // 172.16.0.0 - 172.31.255.255
  	  if ((octet1 == 172 || octet1Dst==172) && (octet2 >= 16 || octet2Dst >=16 ) && (octet2 <= 31 || octet2Dst<=31))
  	  {
       GPU_results[threadIndex].maliciousIP=1;
		}
    // 192.168.0.0 - 192.168.255.255
   	 if ((octet1 == 192 || octet1Dst == 192) && (octet2 == 168 || octet2Dst == 168))
   	 {
      GPU_results[threadIndex].maliciousIP=1;
	}
	
	/*Computing the checksum and checking if the sum is 0*/
	
		 //printf("Source IP address is %u.%u.%u.%u\n",octet1,octet2,octet3,octet4);		
	}
	
	if(IS_TCP())
	{
	/*Checking if TCP Flag bit combination is malicious*/
	if(elements[threadIdx.x].flags == 3 ||
	elements[threadIdx.x].flags == 11 || elements[threadIdx.x].flags == 7 ||
	elements[threadIdx.x].flags == 15 || elements[threadIdx.x].flags == 1 ||
	elements[threadIdx.x].flags == 0 || elements[threadIdx.x].unused != 0)
	{
	GPU_results[threadIndex].flags = GPU_data[threadIndex].flags;
	if(elements[threadIdx.x].unused == 0) GPU_results[threadIndex].maliciousFlags = 1;	
	else GPU_results[threadIndex].maliciousReserved = 1;
	} 	
	
	/*Checking if the source or Destination port is 0*/
	if(elements[threadIdx.x].sport == 0 || elements[threadIdx.x].dport == 0) 
	{
	GPU_results[threadIndex].sport = elements[threadIdx.x].sport;
	GPU_results[threadIndex].dport = elements[threadIdx.x].dport;
	GPU_results[threadIndex].maliciousPort = 1;
	}
	
	/*Checking if the ackowledgement bit is set, than the ACK number should not be zero*/
	if(elements[threadIdx.x].flags & 16 ==1 && elements[threadIdx.x].ack==0)
	GPU_results[threadIndex].maliciousAck=1;
	
	/*Checking if TCP Packet is broadcast packet*/
	if(octet4Dst == 0 || octet4Dst == 255)
	GPU_results[threadIndex].maliciousDst=1;
	}	 												
	__syncthreads();

  // atomicAdd(&totalThreads,1);
}

template<typename T,typename R> 
__device__ __inline__ void COMPOUND_NAME(ANALYSIS_NAME,ipScanAnalysisCode)(packet_t* GPU_buffer, T* GPU_data, R* GPU_results, analysisState_t state,int *counter,int thresHold){

	ipscananalysis<ANALYSIS_INPUT_TYPE,ANALYSIS_INPUT_TYPE>(GPU_buffer,GPU_data,GPU_results,state,counter,thresHold);
	//while(totalThreads<3840) { }; 
	}

/***** END OF PORTSCAN DETECTOR ANALYSIS *****/


#endif //__CUDACC__
/* Redefine DATA_ELEMENT and RESULT_ELEMENT */
#undef DATA_ELEMENT
#define DATA_ELEMENT GPU_data[POS] 

#undef RESULT_ELEMENT
#define RESULT_ELEMENT GPU_results[POS] 



