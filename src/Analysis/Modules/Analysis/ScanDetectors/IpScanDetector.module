/* 
 MODULE:IpScan detector
 TYPE: Analysis

 PrePreprocessor orders (ppp.sh):

 ###PATTERNS $IPSCAN_DETECTOR$ANALYSIS(

 */

//#warning IpScan Analysis
#ifndef libAnalysisIpScan_h 
#define libAnalysisIpScan_h 

//#include "../Thresholds/Thresholds.h"
#include <inttypes.h>
#include <string>
#include <stdio.h>
using namespace std;

typedef struct {
	//IP
	int maliciousVer;
	int maliciousIP;
	int maliciousFlags;
	int maliciousReserved;
	int maliciousPort;
	int maliciousAck;
	int maliciousDst;
	int maliciousCheckSum;
	int size_packet;
	int signatureFound;
	char* signature;
	const uint8_t* hexsignature;
	char packet;
	int signatureLength;
	uint32_t ipSrc;
} COMPOUND_NAME(ANALYSIS_NAME, ipScanAnalysis_t);

#endif  //libAnalysisIpScan

/* Redefine TYPES */
#undef  ANALYSIS_INPUT_TYPE
#define ANALYSIS_INPUT_TYPE COMPOUND_NAME(ANALYSIS_NAME,ipScanAnalysis_t)

#ifdef __CUDACC__
/*DATA_ELEMENT.packet = (char*) GET_HEADER_POINTERCHAR;\*/
#define $IPSCAN_DETECTOR$AUTO_MINE()\
		do{\
			DATA_ELEMENT.maliciousReserved = 0;\
			DATA_ELEMENT.maliciousFlags=0;\
			DATA_ELEMENT.maliciousPort=0;\
			DATA_ELEMENT.signatureFound=0;\
			DATA_ELEMENT.signature = "0x48656C6C6F";\
			DATA_ELEMENT.signatureLength = 3;\
			DATA_ELEMENT.packet = GET_PACKET_BYTE;\
			DATA_ELEMENT.ipSrc = -1;\
		}while(0)

/***** IPSCAN DETECTOR ANALYSIS *****/
#define $IPSCAN_DETECTOR$ANALYSIS(threshold) \
		COMPOUND_NAME(ANALYSIS_NAME,ipScanAnalysisCode)(GPU_buffer,GPU_data,GPU_results,state,counter,threshold);\
		__syncthreads()

template<typename T,typename R>
__device__ void ipscananalysis(packet_t* GPU_buffer, T* GPU_data, R* GPU_results, analysisState_t state,int *counter,int thresHold) {

	/* Erases duplicates and counts elements inside block */

	__shared__ T elements[96];
	__shared__ int packetLen;
	int threadIndex = blockIdx.x*blockDim.x + threadIdx.x;

	//Mine to Shared to save memory accesses
	elements[threadIdx.x] = cudaSafeGet(&GPU_data[threadIndex]);

	if(IS_IP4()) //Checking if it is a IPv4 Packet
	{
		int verBlock = (elements[14].packet & 0x000000F0) >> 4;
		if(threadIdx.x==0)
		{
			int octet1 = elements[26].packet & 0x000000FF;
			int octet2 = elements[27].packet & 0x000000FF;

			int ipSrc = (octet1 << 24) + (octet2 << 16)\
					+ ((elements[28].packet & 0x000000FF )<< 8) + (elements[29].packet & 0x000000FF);

			if (octet1 == 10 /*|| octet1Dst==10*/)
			{
				printf(" 192. %d \n",threadIndex);
				GPU_results[threadIndex].maliciousIP=1;
			}
			// 172.16.0.0 - 172.31.255.255
			if ((octet1 == 172 /*|| octet1Dst==172*/) && (octet2 >= 16 /*|| octet2Dst >=16*/ ) && (octet2 <= 31/* || octet2Dst<=31*/))
			{
				printf(" 192. %d \n",threadIndex);
				GPU_results[threadIndex].maliciousIP=1;
			}
			// 192.168.0.0 - 192.168.255.255
			if ((octet1 == 192 /*|| octet1Dst == 192*/) && (octet2 == 168/* || octet2Dst == 168*/))
			{
				printf(" 192. %d \n",threadIndex);
				GPU_results[threadIndex].maliciousIP=1;
			}

			//printf("IPv4 version %d Source Ip Address %d",verBlock,ipSrc);
			GPU_results[threadIndex].ipSrc = ipSrc;
			if(verBlock !=4 && verBlock !=6) GPU_results[threadIndex].maliciousVer=1;
		}
	}
	__syncthreads();

}

template<typename T,typename R>
__device__ __inline__ void COMPOUND_NAME(ANALYSIS_NAME,ipScanAnalysisCode)(packet_t* GPU_buffer, T* GPU_data, R* GPU_results, analysisState_t state,int *counter,int thresHold) {

	ipscananalysis<ANALYSIS_INPUT_TYPE,ANALYSIS_INPUT_TYPE>(GPU_buffer,GPU_data,GPU_results,state,counter,thresHold);
	//while(totalThreads<3840) { };
}

/***** END OF PORTSCAN DETECTOR ANALYSIS *****/

#endif //__CUDACC__
/* Redefine DATA_ELEMENT and RESULT_ELEMENT */
#undef DATA_ELEMENT
#define DATA_ELEMENT GPU_data[POS] 

#undef RESULT_ELEMENT
#define RESULT_ELEMENT GPU_results[POS] 

