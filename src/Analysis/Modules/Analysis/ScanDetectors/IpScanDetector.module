/* 
 MODULE:IpScan detector
 TYPE: Analysis

 PrePreprocessor orders (ppp.sh):

 ###PATTERNS $IPSCAN_DETECTOR$ANALYSIS(

 */

//#warning IpScan Analysis
#ifndef libAnalysisIpScan_h 
#define libAnalysisIpScan_h 

//#include "../Thresholds/Thresholds.h"
#include <inttypes.h>
#include <string>
#include <stdio.h>
using namespace std;

typedef struct {
	//IP
	int maliciousVer;
	int maliciousIP;
	int maliciousFlags;
	int maliciousReserved;
	int maliciousPort;
	int maliciousAck;
	int maliciousDst;
	int maliciousCheckSum;
	int size_packet;
	int signatureFound;
	int ipPacket;
	char* signature;
	const uint8_t* hexsignature;
	char packet;
	int signatureLength;
	uint32_t ipSrc;
	uint32_t ipDst;
	int flags;
	int sport;
} COMPOUND_NAME(ANALYSIS_NAME, ipScanAnalysis_t);

#endif  //libAnalysisIpScan

/* Redefine TYPES */
#undef  ANALYSIS_INPUT_TYPE
#define ANALYSIS_INPUT_TYPE COMPOUND_NAME(ANALYSIS_NAME,ipScanAnalysis_t)

#ifdef __CUDACC__
/*DATA_ELEMENT.packet = (char*) GET_HEADER_POINTERCHAR;\*/
#define $IPSCAN_DETECTOR$AUTO_MINE()\
		do{\
			DATA_ELEMENT.maliciousReserved = 0;\
			DATA_ELEMENT.maliciousFlags=0;\
			DATA_ELEMENT.maliciousPort=0;\
			DATA_ELEMENT.signatureFound=0;\
			DATA_ELEMENT.signature = "0x48656C6C6F";\
			DATA_ELEMENT.signatureLength = 3;\
			DATA_ELEMENT.packet = GET_PACKET_BYTE;\
			DATA_ELEMENT.ipSrc = -1;\
		}while(0)

/***** IPSCAN DETECTOR ANALYSIS *****/
#define $IPSCAN_DETECTOR$ANALYSIS(threshold) \
		COMPOUND_NAME(ANALYSIS_NAME,ipScanAnalysisCode)(GPU_buffer,GPU_data,GPU_results,state,counter,threshold);\
		__syncthreads()
__device__ int lastTwoBytes(char pack)
{
	return pack & 0x000000FF;
}
template<typename T,typename R>
__device__ void ipscananalysis(packet_t* GPU_buffer, T* GPU_data, R* GPU_results, analysisState_t state,int *counter,int thresHold) {

	/* Erases duplicates and counts elements inside block */


	__shared__ T elements[96];
	__shared__ int packetLen;
	int threadIndex = blockIdx.x*blockDim.x + threadIdx.x;

	//Mine to Shared to save memory accesses
	if(threadIdx.x < 54)
		elements[threadIdx.x] = cudaSafeGet(&GPU_data[threadIndex]);
	__syncthreads();

	if(threadIdx.x == 14) // Representative thread for warp 0
	{
		if(IS_IP4()) //Checking if it is a IPv4 Packet
		{
			GPU_results[blockIdx.x].ipPacket = 1;
			int verBlock = (elements[14].packet & 0x000000F0) >> 4;
			if(verBlock !=4 && verBlock !=6) GPU_results[threadIndex].maliciousVer=1;

			int octet1 = elements[26].packet & 0x000000FF;
			int octet2 = elements[27].packet & 0x000000FF;
			int octet1Dst = elements[30].packet & 0x000000FF;
			int octet2Dst = elements[31].packet & 0x000000FF;

			if (octet1 == 10 || octet1Dst == 10)
			{
				GPU_results[threadIndex].maliciousIP=1;
			}
			// 172.16.0.0 - 172.31.255.255
			if ((octet1 == 172 || octet1Dst == 172 ) && (octet2 >= 16 || octet2Dst >=16 ) && (octet2 <= 31 || octet2Dst<=31))
			{
				GPU_results[threadIndex].maliciousIP=1;
			}
			// 192.168.0.0 - 192.168.255.255
			if ((octet1 == 192  || octet1Dst == 192) && (octet2 == 168 || octet2Dst == 168))
			{
				GPU_results[threadIndex].maliciousIP=1;
			}
			int checksum = ((elements[14].packet & 0x000000FF)<<8 + (elements[15].packet & 0x000000FF)) +
					((elements[16].packet & 0x000000FF)<<8 + (elements[17].packet & 0x000000FF)) +
					((elements[18].packet & 0x000000FF)<<8  + (elements[19].packet & 0x000000FF )) +
					((elements[20].packet & 0x000000FF)<<8 + (elements[21].packet & 0x000000FF)) +
					((elements[22].packet & 0x000000FF)<<8  + (elements[23].packet & 0x000000FF)) +
					((elements[24].packet & 0x000000FF)<<8 + (elements[25].packet & 0x000000FF)) +
					(lastTwoBytes(elements[26].packet)<<8 + lastTwoBytes(elements[27].packet)) +
					(lastTwoBytes(elements[28].packet)<<8 + lastTwoBytes(elements[29].packet)) +
					(lastTwoBytes(elements[30].packet)<<8 + lastTwoBytes(elements[31].packet)) +
					(lastTwoBytes(elements[32].packet)<<8 + lastTwoBytes(elements[33].packet));

			unsigned int sum = ~(checksum>>16 + (checksum & 0xFFFF));
			if(sum!=-1) GPU_results[threadIndex].maliciousCheckSum = 1;

		}
	}
	else if(threadIdx.x == 33)
	{
		if(IS_TCP())
		{

			GPU_results[threadIndex].flags = elements[47].packet;
			GPU_results[threadIndex].sport = lastTwoBytes(elements[34].packet) << 8 + elements[35].packet;
			if(elements[33].packet == 255)
				GPU_results[threadIndex].maliciousDst = 1;

			if((elements[34].packet == 0 && elements[35].packet == 0) ||
					(elements[36].packet == 0 && elements[37].packet == 0))
				GPU_results[threadIndex].maliciousPort = 1;

			int ackNo = elements[42].packet<<24 + elements[43].packet<<16 + elements[44].packet<<8 + elements[45].packet;
			if(elements[47].packet & 16 ==1 && (ackNo == 0))
				GPU_results[threadIndex].maliciousAck = 1;

			int reservedVal = elements[46].packet << 4;
			if(reservedVal != 0) GPU_results[threadIndex].maliciousReserved = 1;

			if(elements[47].packet == 3 || elements[47].packet == 11
					|| elements[47].packet == 7 || elements[47].packet == 15 || elements[47].packet == 1 ||
					elements[47].packet == 0)
			{
				GPU_results[threadIndex].maliciousFlags = 1;
			}
		}
	}
	__syncthreads();

	if(IS_IP4() && threadIdx.x ==0)
	{
		GPU_results[blockIdx.x].ipPacket = 1;
	uint32_t ipSrc = ((elements[26].packet & 0x000000FF)  << 24) + ((elements[27].packet & 0x000000FF)  << 16)
									+ ((elements[28].packet & 0x000000FF )<< 8) + (elements[29].packet & 0x000000FF);
	uint32_t ipDst = ((elements[30].packet & 0x000000FF)  << 24) + ((elements[31].packet & 0x000000FF)  << 16)
							+ ((elements[32].packet & 0x000000FF )<< 8) + (elements[33].packet & 0x000000FF);

	GPU_results[blockIdx.x].ipSrc = ipSrc;
	GPU_results[blockIdx.x].ipDst = ipDst;
	}

	/*Payload Signature Matching*/

	if(threadIdx.x >= 54)
			elements[threadIdx.x] = cudaSafeGet(&GPU_data[threadIndex]);
		__syncthreads();

	if(threadIdx.x >=54)
	{
		GPU_results[threadIndex].signature = elements[threadIdx.x].signature;
		char *input = elements[threadIdx.x].signature;
		int val1 = (input[2] - 48) > 9 ? (input[2] - 55) * 16 : (input[2] - 48) * 16;
		int val2 = (input[3] - 48) > 9 ? (input[3] - 55) : (input[3] - 48);
		int val = val1 + val2;
		if(elements[threadIdx.x].packet == val)
		{
			int j = 1;
			int k = 4;
			int i = threadIdx.x;
			while (input[k]!='\0' && i+j < 96)
			{
				val1 = (input[k] - 48) > 9 ? (input[k] - 55) * 16 : (input[k] - 48) * 16;
				val2 = (input[k+1] - 48) > 9 ? (input[k+1] - 55) : (input[k+1] - 48);
				val = val1 + val2;
				if(elements[i+j].packet!=val)
					break;
				else {j++;k=k+2;}
			}
			if(input[k]=='\0') GPU_results[threadIndex].signatureFound = 1;
		}
	}
}

template<typename T,typename R>
__device__ __inline__ void COMPOUND_NAME(ANALYSIS_NAME,ipScanAnalysisCode)(packet_t* GPU_buffer, T* GPU_data, R* GPU_results, analysisState_t state,int *counter,int thresHold) {

	ipscananalysis<ANALYSIS_INPUT_TYPE,ANALYSIS_INPUT_TYPE>(GPU_buffer,GPU_data,GPU_results,state,counter,thresHold);
	//while(totalThreads<3840) { };
}

/***** END OF PORTSCAN DETECTOR ANALYSIS *****/

#endif //__CUDACC__
/* Redefine DATA_ELEMENT and RESULT_ELEMENT */
#undef DATA_ELEMENT
#define DATA_ELEMENT GPU_data[POS] 

#undef RESULT_ELEMENT
#define RESULT_ELEMENT GPU_results[POS] 

