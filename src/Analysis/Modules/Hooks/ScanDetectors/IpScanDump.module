/* 
	MODULE:IpScan dumper 
	TYPE: Hook

	PrePreprocessor orders (ppp.sh): 
	###PATTERNS $IPSCAN_DETECTOR$DUMPER$DUMP_ALARMS_TO_FILE( $IPSCAN_DETECTOR$DUMPER$DUMP_ALARMS_TO_STDERR(

*/


//#warning  IpScan Dumper Hook loaded

#include <iostream>
#include "../hostTimeUtils.h"

#define $IPSCAN_DETECTOR$DUMPER$DUMP_ALARMS_TO_FILE(filename,severe,critical)\
	dumpIpScanAlarmsToFile(packetBuffer,results,state,auxBlocks,(char*)filename,severe,critical)

#define $IPSCAN_DETECTOR$DUMPER$DUMP_ALARMS_TO_STDERR(severe,critical)\
	dumpIpScanAlarmsToOstream(cerr, packetBuffer,results,state,auxBlocks,severe,critical)


template<typename R>
void inline dumpIpScanAlarmsToFile(PacketBuffer* packetBuffer,R* results, analysisState_t state, int64_t* auxBlocks, char* filename,int severeLimit, int criticalLimit){

	 //cout<<"TCP = "<<(*results).indexTcp<<"UDP= "<< (*results).indexUdp<<"ICMP ="<< (*results).indexIcmp; 			
  	cout<<endl<<"*********************CPU SECTION***********************************"<<endl;
  	cout<<"TCP = "<<results[0].indexTcp<<"UDP= "<< results[0].indexUdp<<"ICMP = "<< results[0].indexIcmp<<endl;
	bool alreadyExists;
	ofstream file;
	fstream fin;

	//If File does not exist mark flag
	fin.open(filename,ios::in);
	alreadyExists = fin.is_open();
	fin.close();

	//Open
	file.open(filename,ios::out | ios::app);

	//If was empty, fill with headers
	if(!alreadyExists){
	        file << "#AutoGenerated Output by"STR(APP_NAME)" IpScanDetector Module"<<endl;
        	file << "#Elapsed time format: [ ANALYSIS_START_TIME(timestamp) ANALYSIS_END_TIME(timestamp) ] //At the end list of alarms"<<endl; 
        	file << "#Alarm Output Format: ANALYSIS_NAME> IP_SOURCE RATE(ips/second) IPS_COUNTER(number of different ips) ALARM_TYPE"<<endl<<endl;
	}

	dumpIpScanAlarmsToOstream(file, packetBuffer,results,state,auxBlocks,severeLimit,criticalLimit);
	
	//TODO: leave it opened till the end
	file.close();

}

template<typename R>
void inline dumpIpScanAlarmsToOstream(ostream& os, PacketBuffer* packetBuffer,R* results, analysisState_t state, int64_t* auxBlocks, int severeLimit, int criticalLimit){

	int i,j;
	bool hasResults;
	uint8_t* pointer;

	//time vars	
	time_t aux;
  	struct tm * timeinfo;
  		
	
	//Dump alarms
	for(i = 0,hasResults = false;i<state.windowState.totalNumberOfBlocks;i++){
		//cout<<"Hello inside i loop Hooks"<<state.windowState.totalNumberOfBlocks<<endl;
		for(j=0;j<128;j++)
		{
		if(results[i*ANALYSIS_TPB+j].malicious == 1)
		cout<<"Results = "<<results[i*ANALYSIS_TPB+j].malicious<<endl;					
		}
				
		for(j = 0;j<auxBlocks[i];j++){
		cout<<"Hello inside j loop Hooks"<<auxBlocks[i]<<endl;
			//cout<<"Results = "<< results[i*ANALYSIS_TPB+j].rate << " " << results[i*ANALYSIS_TPB+j].counter<<" ";
				
			cout<<"Results = "<<results[i*ANALYSIS_TPB+j].malicious<<endl;
			
			//Check if result is valid (has not been post filtered) 
			if(results[i*ANALYSIS_TPB+j].rate != 0.0){
					//IP source
				pointer = (uint8_t*)&results[i*ANALYSIS_TPB+j].ipSrc;
				os<<STR(ANALYSIS_NAME)"> ";				
				os<<(unsigned int)*(pointer+3)<<"."<<(unsigned int)*(pointer+2)<<"."<<(unsigned int)*(pointer+1)<<"."<<(unsigned int)*(pointer)<<" ";
				//Rate and counter
				os << results[i*ANALYSIS_TPB+j].rate << " " << results[i*ANALYSIS_TPB+j].counter<<" ";
				
				//Alarm class
				if(results[i*ANALYSIS_TPB+j].rate > (float)criticalLimit)
					os <<"CRITICAL_ALARM"<<endl;	
				else if(results[i*ANALYSIS_TPB+j].rate > (float)severeLimit)
					os <<"SEVERE_ALARM"<<endl;	
				else
					os <<"ALARM"<<endl;	
				
				hasResults = true;	
			}
		}

		
	}

	if(hasResults){
		//Analysis start timestamp (1rst packet)
		os<<"#"STR(ANALYSIS_NAME)"> ";
		os<<"[ "<<tv2usec(state.windowState.windowStartTime)<<" "; 	
		//Seek to supress stupid \n from ctime
		//	os.seekp(ios_base::cur-1);	

		//Analysis end timestamp (last packet)

		os<<tv2usec(state.windowState.windowEndTime)<<" ] ";		
	
		//Dump current time (time of the dump)
		time ( &aux );
		timeinfo = localtime ( &aux );
	        os << " Dumped at: "<<asctime(timeinfo)<<endl<<endl;
	}
	
}
	
