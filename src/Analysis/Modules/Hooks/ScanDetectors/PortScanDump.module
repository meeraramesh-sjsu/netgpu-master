/* 
	MODULE:PortScan dumper 
	TYPE: Hook

	PrePreprocessor orders (ppp.sh): 
	###PATTERNS $PORTSCAN_DETECTOR$DUMPER$DUMP_ALARMS_TO_FILE( $PORTSCAN_DETECTOR$DUMPER$DUMP_ALARMS_TO_STDERR(

*/

//#warning  PortScan Dumper Hook loaded

#include <iostream>
#include "../hostTimeUtils.h"

#define $PORTSCAN_DETECTOR$DUMPER$DUMP_ALARMS_TO_FILE(filename,severe,critical)\
	dumpPortScanAlarmsToFile(packetBuffer,results,state,auxBlocks,(char*)filename,severe,critical)

#define $PORTSCAN_DETECTOR$DUMPER$DUMP_ALARMS_TO_STDERR(severe,critical)\
	dumpPortScanAlarmsToOstream(cerr, packetBuffer,results,state,auxBlocks,severe,critical)


template<typename R>
void inline dumpPortScanAlarmsToFile(PacketBuffer* packetBuffer,R* results, analysisState_t state, int64_t* auxBlocks, char* filename,int severeLimit, int criticalLimit){

	bool alreadyExists;
	ofstream file;
	fstream fin;

	//If File does not exist mark flag
	fin.open(filename,ios::in);
	alreadyExists = fin.is_open();
	fin.close();

	//Open
	file.open(filename,ios::out | ios::app);

	//If was empty, fill with headers
	if(!alreadyExists){
	        file << "#AutoGenerated Output by"STR(APP_NAME)" PortScanDetector Module"<<endl;
        	file << "#Elapsed time format: #ANALYSIS_NAME>[ ANALYSIS_START_TIME(timestamp) ANALYSIS_END_TIME(timestamp) ] dumpedTime_ info//At the end list of alarms"<<endl; 
        	file << "#Alarm Output Format: ANALYSIS_NAME> IP_SOURCE IP_DEST PROTOCOL_TYPE(transport) DEST_PORT RATE(ports/second) PORT_COUNTER(number of different ports) ALARM_TYPE"<<endl<<endl;
	}

	dumpPortScanAlarmsToOstream(file, packetBuffer,results,state,auxBlocks,severeLimit,criticalLimit);
	
	//TODO: leave it opened till the end
	file.close();

}

template<typename R>
void inline dumpPortScanAlarmsToOstream(ostream& os, PacketBuffer* packetBuffer,R* results, analysisState_t state, int64_t* auxBlocks, int severeLimit, int criticalLimit){

	int i,j;
	bool hasResults;
	uint8_t* pointer;

	//time vars	
	time_t aux;
  	struct tm * timeinfo;

	//Dump alarms
	for(i = 0,hasResults = false;i<state.windowState.totalNumberOfBlocks;i++){
	
		for(j = 0;j<auxBlocks[i];j++){

			//Check if result is valid (has not been post filtered) 
			if(results[i*ANALYSIS_TPB+j].rate != 0.0){
				
				os<<STR(ANALYSIS_NAME)"> ";				

				//IP source
				pointer = (uint8_t*)&results[i*ANALYSIS_TPB+j].ipSrc;
				os<<(unsigned int)*(pointer+3)<<"."<<(unsigned int)*(pointer+2)<<"."<<(unsigned int)*(pointer+1)<<"."<<(unsigned int)*(pointer)<<" ";
				//IpDst
				pointer = (uint8_t*)&results[i*ANALYSIS_TPB+j].dstParams.ipDst;
				os<<(unsigned int)*(pointer+3)<<"."<<(unsigned int)*(pointer+2)<<"."<<(unsigned int)*(pointer+1)<<"."<<(unsigned int)*(pointer)<<" ";
				//Transport Protocol Type
				if(results[i*ANALYSIS_TPB+j].dstParams.protocolType == $PORTSCAN_DETECTOR$TCP_PROTO)
					os <<"TCP ";
				else
					os <<"UDP ";
				//Rate and counter
				os << results[i*ANALYSIS_TPB+j].rate << " " << results[i*ANALYSIS_TPB+j].counter<<" ";
				
				//Alarm class
				if(results[i*ANALYSIS_TPB+j].rate > (float)criticalLimit)
					os <<"CRITICAL_ALARM"<<endl;	
				else if(results[i*ANALYSIS_TPB+j].rate > (float)severeLimit)
					os <<"SEVERE_ALARM"<<endl;	
				else
					os <<"ALARM"<<endl;	
				
				hasResults = true;	
			}
		}

		
	}

	if(hasResults){
		//Analysis start timestamp (1rst packet) 
		os<<"#"STR(ANALYSIS_NAME)"> ";
		//	aux = tv2usec(*state.windowState.windowStartTime);
		//	os<<ctime(&aux)<<" ";
		os<<"[ "<<tv2usec(state.windowState.windowStartTime)<<" "; 	
	
		//Seek to supress stupid \n from ctime
		//	os.seekp(ios_base::cur-1);	

		//Analysis end timestamp (last packet)
		os<<tv2usec(state.windowState.windowEndTime)<<" ] ";		
	
		//Dump current time (time of the dump)
		time ( &aux );
		timeinfo = localtime ( &aux );
	        os << " Dumped at: "<<asctime(timeinfo)<<endl<<endl;
	}
	
}
	
